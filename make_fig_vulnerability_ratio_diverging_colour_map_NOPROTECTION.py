#!/usr/bin/env python3
"""
Make Figure â€“ Choropleth of Vulnerability Ratio with Diverging Colour Map (NOPROTECTION scenario).

The vulnerability ratio is defined as:
(% poorest 20% exposed) / (% total population exposed)
= (poorest_20_affected / poorest_20_population) / (total_affected / total_population)

A ratio > 1 indicates the poorest 20% are disproportionately exposed.
A ratio < 1 indicates the poorest 20% are less exposed than the general population.
A ratio = 1 indicates proportional exposure.

The map uses a diverging color scheme centered around a ratio of 1.
The title is placed at the bottom of the figure.
All text is rendered using a sans-serif font.
A detailed text description of the figure is generated.

Usage (example):
    python make_fig_vulnerability_ratio_diverging_colour_map_NOPROTECTION.py --ssp SSP2 --year 2020 --rp RP100
"""
import argparse
import os
import geopandas as gpd
import matplotlib
matplotlib.use("Agg")          # headless / SLURM safe
import matplotlib.pyplot as plt
import mapclassify
import numpy as np
import pandas as pd # For more complex data handling if needed

# Set sans-serif font globally for the script
plt.rcParams['font.family'] = 'sans-serif'

# ----------------------------------------------------------------------
# Hard-wired roots (consistent with other make_fig scripts)
BASE_OUT_DIR = "/hdrive/all_users/wiederkehr/analysis/analysis_runs_output_all_combinations_NOPROTECTION/"
FIG_DIR      = "/hdrive/all_users/wiederkehr/analysis/bachelor/"
os.makedirs(FIG_DIR, exist_ok=True)

def build_paths(ssp: str, year: str, rp: str):
    """Constructs file paths for input GeoJSON and output files."""
    results_dir = os.path.join(BASE_OUT_DIR, f"results_{ssp}_{year}_{rp}")
    geojson_path = os.path.join(results_dir, f"analysis_results_{ssp}_{year}_{rp}.geojson")
    
    base_filename = f"vulnerability_ratio_diverging_{ssp}_{year}_{rp}_NOPROTECTION"
    png_path = os.path.join(FIG_DIR, f"{base_filename}.png")
    txt_path = os.path.join(FIG_DIR, f"description_{base_filename}.txt")
    
    return geojson_path, png_path, txt_path

def plot_vulnerability_ratio_diverging(geojson_path: str, png_path: str, txt_path: str, ssp: str, year: str, rp: str):
    """
    Generates a choropleth map of the vulnerability ratio with a diverging color map
    and a detailed text description.
    """
    try:
        gdf = gpd.read_file(geojson_path)
    except Exception as e:
        print(f"Error reading GeoJSON file {geojson_path}: {e}")
        return

    required_cols = ['poorest_20_affected', 'poorest_20_population', 'total_affected', 'total_population']
    for col in required_cols:
        if col not in gdf.columns:
            print(f"Required column '{col}' not found in GeoJSON. Skipping plot generation.")
            # Create an empty text file indicating the error
            with open(txt_path, 'w') as f:
                f.write(f"Error: Required column '{col}' not found in GeoJSON '{geojson_path}'. Plot generation aborted.")
            return

    # Store initial NaN state for required_cols before any modifications to gdf
    initial_input_is_nan = gdf[required_cols].isnull()

    # Calculate shares, handling potential division by zero by yielding NaN
    gdf["share_poorest20_exposed"] = np.where(
        gdf["poorest_20_population"] > 0,
        gdf["poorest_20_affected"] / gdf["poorest_20_population"],
        np.nan
    )
    gdf["share_total_exposed"] = np.where(
        gdf["total_population"] > 0,
        gdf["total_affected"] / gdf["total_population"],
        np.nan
    )

    # Calculate vulnerability ratio (raw, before inf replacement)
    # This helps distinguish between 0/0 (NaN) and X/0 (inf)
    gdf["vulnerability_ratio_raw"] = gdf["share_poorest20_exposed"] / gdf["share_total_exposed"]

    # Final ratio after inf replacement
    gdf["vulnerability_ratio"] = gdf["vulnerability_ratio_raw"].replace([np.inf, -np.inf], np.nan)

    data_col_name = "vulnerability_ratio"
    valid_data = gdf[data_col_name].dropna()
    all_nan_gdf = gdf[gdf[data_col_name].isnull()].copy() # Use .copy() to avoid SettingWithCopyWarning

    # --- Categorize NaN regions ---
    nan_case_counts = {
        'initial_input_nan': 0,
        'zero_p20_pop': 0,
        'zero_total_pop': 0,
        'ratio_0_div_0': 0,
        'ratio_x_div_0': 0, # Inf converted to NaN
        'unexplained_nan': 0 
    }
    nan_case_examples = {
        'initial_input_nan': [],
        'zero_p20_pop': [],
        'zero_total_pop': [],
        'ratio_0_div_0': [],
        'ratio_x_div_0': [],
        'unexplained_nan': []
    }
    MAX_EXAMPLES_PER_CASE = 3

    # Determine region identifier column
    if 'nuts_id' in gdf.columns:
        region_id_col = 'nuts_id'
    elif 'region_name' in gdf.columns:
        region_id_col = 'region_name'
    else:
        # If no specific ID column, use the index. Convert to string for consistency.
        all_nan_gdf['_temp_id_col_'] = all_nan_gdf.index.astype(str)
        region_id_col = '_temp_id_col_'

    for idx, row in all_nan_gdf.iterrows():
        region_identifier = str(row[region_id_col])
        
        # Case 3: Propagation of Missing Input Data (checks the original required columns for this specific row index)
        if initial_input_is_nan.loc[idx].any():
            nan_case_counts['initial_input_nan'] += 1
            if len(nan_case_examples['initial_input_nan']) < MAX_EXAMPLES_PER_CASE:
                nan_case_examples['initial_input_nan'].append(region_identifier)
            continue # Prioritize this as the root cause

        # Case 1a: Zero poorest_20_population (original population was 0)
        # Check original gdf for this, as row is from all_nan_gdf which might have derived NaNs
        if gdf.loc[idx, 'poorest_20_population'] == 0:
            nan_case_counts['zero_p20_pop'] += 1
            if len(nan_case_examples['zero_p20_pop']) < MAX_EXAMPLES_PER_CASE:
                nan_case_examples['zero_p20_pop'].append(region_identifier)
            continue
            
        # Case 1b: Zero total_population (original population was 0, and p20_pop was not 0)
        if gdf.loc[idx, 'total_population'] == 0:
            nan_case_counts['zero_total_pop'] += 1
            if len(nan_case_examples['zero_total_pop']) < MAX_EXAMPLES_PER_CASE:
                nan_case_examples['zero_total_pop'].append(region_identifier)
            continue

        # Case 2b: X/0 (Inf converted to NaN) - check the raw ratio for Inf
        if np.isinf(row['vulnerability_ratio_raw']):
            nan_case_counts['ratio_x_div_0'] += 1
            if len(nan_case_examples['ratio_x_div_0']) < MAX_EXAMPLES_PER_CASE:
                nan_case_examples['ratio_x_div_0'].append(region_identifier)
            continue

        # Case 2a: 0/0 - both shares were zero, leading to NaN in vulnerability_ratio_raw.
        # Check if raw ratio was NaN AND both shares were 0.
        if pd.isna(row['vulnerability_ratio_raw']) and \
           pd.notna(row['share_poorest20_exposed']) and row['share_poorest20_exposed'] == 0 and \
           pd.notna(row['share_total_exposed']) and row['share_total_exposed'] == 0:
            nan_case_counts['ratio_0_div_0'] += 1
            if len(nan_case_examples['ratio_0_div_0']) < MAX_EXAMPLES_PER_CASE:
                nan_case_examples['ratio_0_div_0'].append(region_identifier)
            continue
            
        # Fallback for any other NaN reasons not explicitly caught.
        nan_case_counts['unexplained_nan'] +=1
        if len(nan_case_examples['unexplained_nan']) < MAX_EXAMPLES_PER_CASE:
            nan_case_examples['unexplained_nan'].append(region_identifier)
    
    if '_temp_id_col_' in all_nan_gdf.columns: # Check if temp col was added to all_nan_gdf
        pass # No need to drop from original gdf if only added to the copy

    # --- Define plotting scheme and colormap ---
    cmap_to_use = "RdBu_r"  # Red-White-Blue diverging: low ratios blue (less vulnerable), high ratios red (more vulnerable)
    plot_scheme_name = "UserDefined" 
    # Define bins to center around 1.0 for the diverging map
    # Classes: <0.8 | 0.8-0.95 | 0.95-1.05 (neutral) | 1.05-1.2 | >1.2
    # These bins are chosen to highlight deviations from proportional exposure (ratio=1)
    user_defined_bins = []
    if not valid_data.empty:
        min_val = valid_data.min()
        max_val = valid_data.max()
        # Ensure bins cover the full range while focusing on the diverging points
        # Bins must be strictly increasing
        raw_bins = sorted(list(set([min_val, 0.8, 0.95, 1.05, 1.2, max_val])))

        # Special case handling: If the minimum value is greater than or equal to 0.8 and the maximum value is less than or equal to 1.2,
        # we have a situation where all data is within the neutral range. In this case, we should not use UserDefined bins
        # as it won't effectively show the divergence. Fallback to Quantiles.
        if min_val >= 0.8 and max_val <= 1.2:
            plot_scheme_name = "Quantiles" # Fallback if data is narrowly ranged around 1
            user_defined_bins = None
            plot_k_val = 5
            classification_kwargs = {'k': plot_k_val}
        else:
            user_defined_bins.append(raw_bins[0])
            for i in range(1, len(raw_bins)):
                if raw_bins[i] > user_defined_bins[-1]: # Ensure strictly increasing
                     user_defined_bins.append(raw_bins[i])
            
            if len(user_defined_bins) < 2: # Not enough unique bins for classification
                plot_scheme_name = "Quantiles" # Fallback if too few bins
                user_defined_bins = None
                plot_k_val = 5
                classification_kwargs = {'k': plot_k_val}
            else:
                classification_kwargs = {'bins': user_defined_bins}
    else: # No valid data
        plot_scheme_name = "EqualInterval" # Placeholder if no data
        user_defined_bins = [0, 1] # Placeholder
        plot_k_val = 1
        classification_kwargs = {'k': plot_k_val}


    # --- Plotting ---
    fig, ax = plt.subplots(1, 1, figsize=(15, 12))
    
    if not valid_data.empty:
        gdf.plot(column=data_col_name, ax=ax, legend=True,
                 scheme=plot_scheme_name, classification_kwds=classification_kwargs,
                 cmap=cmap_to_use,
                 missing_kwds={"color": "lightgrey", "label": "Missing/Invalid Data"},
                 edgecolor='black', linewidth=0.5)
    else: # Handle empty valid_data case for plotting
        gdf.plot(ax=ax, color="lightgrey", edgecolor='black', linewidth=0.5)
        ax.text(0.5, 0.5, "No valid data to display", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=14)


    ax.set_axis_off() # Turn off the axis numbers and ticks

    plot_title = f"Vulnerability Ratio: {ssp} ({year}), {rp}\n(% Poorest 20% Exposed / % Total Population Exposed)"
    fig.suptitle(plot_title, y=0.05, fontsize=14, ha='center', va='bottom') # Title at the bottom

    plt.tight_layout(rect=[0, 0.06, 1, 0.95]) # Adjust layout to make space for suptitle

    try:
        plt.savefig(png_path, dpi=300, bbox_inches='tight')
        print(f"Saved map to {png_path}")
    except Exception as e:
        print(f"Error saving PNG {png_path}: {e}")
    plt.close(fig)

    # --- Generate TXT description ---
    description_lines = []
    description_lines.append("Figure Description: Choropleth Map of Vulnerability Ratio")
    description_lines.append("====================================================================================================")
    description_lines.append("Analysis Parameters:")
    description_lines.append(f"  - Scenario (SSP): {ssp}")
    description_lines.append(f"  - Year: {year}")
    description_lines.append(f"  - Return Period (RP): {rp}")
    description_lines.append(f'Figure Title (located at bottom of plot): "{plot_title.replace(chr(10), " - ")}"') # Use plot_title directly
    description_lines.append(f"Source Data: GeoJSON file '{os.path.basename(geojson_path)}'")
    description_lines.append("====================================================================================================")
    description_lines.append("")
    description_lines.append("1. General Information:")
    description_lines.append("   - This document describes a choropleth map visualizing the 'vulnerability_ratio' for NUTS regions.")
    description_lines.append("   - The vulnerability ratio is defined as:")
    description_lines.append("     (% poorest 20% of population exposed to flooding) / (% total population exposed to flooding)")
    description_lines.append("     = (poorest_20_affected / poorest_20_population) / (total_affected / total_population)")
    description_lines.append("   - Interpretation of the ratio:")
    description_lines.append("     - Ratio > 1: The poorest 20% of the population are disproportionately more exposed to flooding.")
    description_lines.append("     - Ratio < 1: The poorest 20% of the population are disproportionately less exposed.")
    description_lines.append("     - Ratio = 1: The poorest 20% experience exposure proportional to the total population.")
    description_lines.append("   - The \'vulnerability_ratio\' can be undefined (NaN or Not a Number) for a region due to several specific reasons:")
    description_lines.append("     1. Zero Population Denominators in Share Calculation:")
    description_lines.append("        - If \'poorest_20_population\' is zero for a region, the \'share_poorest20_exposed\' (poorest_20_affected / poorest_20_population) cannot be calculated, leading to NaN for this share and subsequently for the ratio.")
    description_lines.append("        - If \'total_population\' is zero for a region, the \'share_total_exposed\' (total_affected / total_population) cannot be calculated, leading to NaN for this share and subsequently for the ratio.")
    description_lines.append("     2. Division by Zero in Final Ratio Calculation:")
    description_lines.append("        - If \'share_total_exposed\' is calculated as zero (e.g., total_affected is 0, or total_population was valid but no one was affected):")
    description_lines.append("          - And \'share_poorest20_exposed\' is also zero, the ratio becomes 0/0, which is undefined (NaN).")
    description_lines.append("          - And \'share_poorest20_exposed\' is a non-zero positive value, the ratio becomes X/0 (e.g., 0.1 / 0), which is infinite. The script explicitly converts these infinite values to NaN to ensure robust plotting and statistical analysis.")
    description_lines.append("     3. Propagation of Missing Input Data:")
    description_lines.append("        - If any of the primary input data columns (\'poorest_20_affected\', \'poorest_20_population\', \'total_affected\', \'total_population\') originally contained missing values (NaN) for a region, these NaNs would typically propagate through the intermediate share calculations and result in a NaN for the final \'vulnerability_ratio\'.")
    
    description_lines.append("   - Quantitative Breakdown of Regions with Undefined (NaN) Vulnerability Ratios:")
    total_nan_regions_from_gdf = gdf[data_col_name].isnull().sum()
    description_lines.append(f"     - Total regions with NaN ratio (from final GDF column): {total_nan_regions_from_gdf}")
    description_lines.append(f"     - Total NaN regions categorized by script: {sum(nan_case_counts.values())} (This should ideally match the count above).")

    # Detailed breakdown:
    desc_initial_nan = f"     - Category 3 (Missing Initial Input): {nan_case_counts['initial_input_nan']} regions. One or more of ('poorest_20_affected', 'poorest_20_population', 'total_affected', 'total_population') were NaN."
    if nan_case_examples['initial_input_nan']:
        desc_initial_nan += f" Examples: {', '.join(map(str, nan_case_examples['initial_input_nan']))}."
    description_lines.append(desc_initial_nan)

    desc_zero_p20 = f"     - Category 1a (Zero Poorest 20% Pop): {nan_case_counts['zero_p20_pop']} regions. 'poorest_20_population' was zero. (Evaluated if initial inputs were not NaN)."
    if nan_case_examples['zero_p20_pop']:
        desc_zero_p20 += f" Examples: {', '.join(map(str, nan_case_examples['zero_p20_pop']))}."
    description_lines.append(desc_zero_p20)

    desc_zero_total = f"     - Category 1b (Zero Total Pop): {nan_case_counts['zero_total_pop']} regions. 'total_population' was zero (and 'poorest_20_population' was not zero). (Evaluated if initial inputs not NaN and p20 pop not zero)."
    if nan_case_examples['zero_total_pop']:
        desc_zero_total += f" Examples: {', '.join(map(str, nan_case_examples['zero_total_pop']))}."
    description_lines.append(desc_zero_total)
    
    desc_x_div_0 = f"     - Category 2b (Ratio X/0 -> Inf -> NaN): {nan_case_counts['ratio_x_div_0']} regions. 'share_total_exposed' was zero while 'share_poorest20_exposed' was non-zero. (Evaluated after previous checks)."
    if nan_case_examples['ratio_x_div_0']:
        desc_x_div_0 += f" Examples: {', '.join(map(str, nan_case_examples['ratio_x_div_0']))}."
    description_lines.append(desc_x_div_0)

    desc_0_div_0 = f"     - Category 2a (Ratio 0/0 -> NaN): {nan_case_counts['ratio_0_div_0']} regions. Both 'share_poorest20_exposed' and 'share_total_exposed' were zero. (Evaluated after previous checks)."
    if nan_case_examples['ratio_0_div_0']:
        desc_0_div_0 += f" Examples: {', '.join(map(str, nan_case_examples['ratio_0_div_0']))}."
    description_lines.append(desc_0_div_0)

    desc_unexplained = f"     - Category Unexplained NaN: {nan_case_counts['unexplained_nan']} regions. Ratio is NaN for reasons not covered by the specific categories above."
    if nan_case_examples['unexplained_nan']:
        desc_unexplained += f" Examples: {', '.join(map(str, nan_case_examples['unexplained_nan']))}."
    description_lines.append(desc_unexplained)
    description_lines.append("")
    description_lines.append("2. Plotting Details:")
    description_lines.append(f"   - Colormap: '{cmap_to_use}' (Diverging: Red for high vulnerability, Blue for low, White/Light grey for neutral/missing).")
    description_lines.append(f"   - Classification Scheme: '{plot_scheme_name}'.")
    if plot_scheme_name == "UserDefined" and user_defined_bins:
        bin_strings = [f"{user_defined_bins[i]:.2f} - {user_defined_bins[i+1]:.2f}" for i in range(len(user_defined_bins)-1)]
        # Add < and > for the first and last class if they represent open ends based on min/max
        if not valid_data.empty:
            if user_defined_bins[0] == valid_data.min() and len(user_defined_bins) >1:
                 bin_strings[0] = f"< {user_defined_bins[1]:.2f}"
            if user_defined_bins[-1] == valid_data.max() and len(user_defined_bins) >1:
                 bin_strings[-1] = f"> {user_defined_bins[-2]:.2f}"
        description_lines.append(f"   - Bins: {user_defined_bins}")
        description_lines.append(f"   - Legend Classes (approximate based on bins): {', '.join(bin_strings)}")
    elif 'classification_kwargs' in locals() and 'k' in classification_kwargs:
        description_lines.append(f"   - Number of classes (k): {classification_kwargs['k']}")
    description_lines.append("   - Regions with missing or invalid data (NaN ratio) are shown in light grey.")
    description_lines.append("====================================================================================================")

    try:
        with open(txt_path, 'w') as f:
            for line in description_lines:
                f.write(line + "\n")
        print(f"Saved description to {txt_path}")
    except Exception as e:
        print(f"Error writing TXT file {txt_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description="Generate a choropleth map of vulnerability ratio with a diverging color map.")
    parser.add_argument("--ssp", type=str, required=True, help="SSP scenario (e.g., SSP2)")
    parser.add_argument("--year", type=str, required=True, help="Year (e.g., 2020)")
    parser.add_argument("--rp", type=str, required=True, help="Return period and scenario (e.g., RP100 or RP100_NOPROTECTION)")
    
    args = parser.parse_args()
    
    geojson_path, png_path, txt_path = build_paths(args.ssp, args.year, args.rp)
    
    print(f"Starting plot generation for {args.ssp}, {args.year}, {args.rp}")
    print(f"Input GeoJSON: {geojson_path}")
    print(f"Output PNG: {png_path}")
    print(f"Output TXT: {txt_path}")
    
    plot_vulnerability_ratio_diverging(geojson_path, png_path, txt_path, args.ssp, args.year, args.rp)
    print("Processing complete.")

if __name__ == "__main__":
    main()
